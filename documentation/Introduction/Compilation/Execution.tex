We are now at a point to see some tangible outcome:
after changing the current directory to \tt{examples/compile/},
compile as \tt{cc_ lib.c_ discount.c_} (sequence doesn't matter),
and assuming things go well, run the file \tt{a.out}.

\code{Introduction/Compilation/example.txt}

We had set the \tt{cc_} alias to use \tt{gcc} as the compiler command.
For \tt{clang} (version 19 or later),
the current set of options generates quite a few warnings; these are harmless,
and can be suppressed with an additional option \tt{-Wno-pointer-arith}, so a
minimal \tt{cc_} alias with \tt{clang} as the compiler would look like:\\

\tt{alias cc_="clang -xc -std=c23 -iprefix '\$HOME'/examples/.include \\}

\tt{-iwithprefix/ellipsis -iwithprefix/dialect -iwithprefix/library \\}

\tt{-iprefix '\$HOME'/examples/include -iwithprefix/. -Wno-pointer-arith"}

Recall a brief mention of the shell script \tt{build.sh};
it creates a directory \tt{object/} within \tt{examples/}
for storing precompiled object files that can be linked later.
We can link the binary \tt{object/lib.o}
which is generated by compiling \tt{lib.c_};
as an alternative to running the build script,
we can also manually compile \tt{lib.c_} with the compile-only option \tt{-c},
which produces an object file named \tt{lib.o}
instead of the executable \tt{a.out}.
Now we can modify the alias as shown below (\tt{gcc} can be
replaced by \tt{clang}, in conjunction with \tt{-Wno-pointer-arith}).\\

\tt{alias cc_="gcc -std=c23 -iprefix '\$HOME'/examples/.include \\}

\tt{-iwithprefix/ellipsis -iwithprefix/dialect -iwithprefix/library \\}

\tt{-iprefix '\$HOME'/examples/include -iwithprefix/. \\}

\tt{'\$HOME'/examples/object/lib.o -xc"}\\

Now we don't need to recompile \tt{lib.c_} for testing every example,
as we can just write \tt{cc_ discount.c_}.
